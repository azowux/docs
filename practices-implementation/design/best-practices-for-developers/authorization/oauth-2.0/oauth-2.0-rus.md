# OAuth 2.0 \(rus\)

## Общая информация

OAuth позволяет провайдеру ресурсов \(**resource provider\)** запрашивать данные пользователя от провайдера идентификации \(**identity provider\)** с разрешения пользователя.   
Это фреймворк **авторизации**.

## Термины

**Resource Provider \(RP\)**  
Провайдер ресурсов - обычно, веб-сайт в схеме взаимодействия

**Identity Provider \(IDP\)**  
Провайдер идентификации - обычно, внешний сервис как Google, GitHub или Facebook

**Client\_id**  
 Client\_id уникален для каждого **RP** и позволяет **RP** идентифицировать себя у **IDP**.

{% hint style="info" %}
Client\_Id **публичен,** позволяет идентифицировать данный RP на IDP.
{% endhint %}

**Access Token**  
Access token является строкой со множеством применений, выпущенный **IDP.** Этот токен может быть использован для доступа к ресурсам пользователя, хранимым на **IDP.**

**Client Secret**  
Client Secret уникален для каждого **RP** позволяет обменять комбинацию valid code и state на **Access Tokens** на **IDP**.

{% hint style="info" %}
Client Secret всегда должен **храниться в секрете**! Если он будет скомпрометирован, злоумышленник сможет эксплуатировать процесс OAuth генерируя новые **Access Tokens.** Это позволит получить доступ к ресурсам пользователя.
{% endhint %}

**Authorization Code**  
Этот код может быть комбинирован со **State** и **Client Secret** с последующим обменом на **IDP** на **Access Token.** Нельзя использовать этот код для доступа к ресурсам пользователя на **IDP,** он должен быть обменен на **Access Token.**

{% hint style="info" %}
Важно подметить, что **Authorization Code** != **Access Token**. **Authorization Code** не может быть использован напрямую для запросов на **IDP** и должен быть обменен на **Access Token**  на сервере **RP.**  

**Authorization Code** будет передан из браузера на сервер **RP,** который обменяет его через **IDP** на **Access Token.**
{% endhint %}

**State  
State** является приватным и должен быть уникальным для каждой OAuth сессии. В сущности, это CSRF Token, который, соответственно, должен быть приватным.

{% hint style="info" %}
**RP** должен подтвердить, что **State**, полученный от браузера, соответствует **State**'у, полученному в шаге 2, чтобы обеспечить защиту от CSRF атаки.
{% endhint %}

**Redirect URI  
Redirect URI** является местом, куда **IDP** перенаправит браузер после завершения цикла аутентификации. После перенаправления сюда, браузер получит **Authorization Code** и **State**.

{% hint style="info" %}
**Redirect URI** должен быть зарегистрирован на IDP как единичное значение или как pattern match \(иначе говоря, должен быть занесен в белый список\)
{% endhint %}

## Процессы

### Authorization Code 

![](../../../../../.gitbook/assets/image%20%285%29.png)

1. Браузер в приложении выбирает провайдера, например, GitHub, нажимает на “Connect to GitHub”.
2. **RP** получает этот запрос и перенаправляет браузер на **IDP**, передавая с запросом публичный **Client\_Id, Redirect URI** и **State**.
3. Браузер принимает redirect и направляется на **IDP** endpoint.
4. **IDP** отвечает и просит пользователя аутентифицировать и подтвердить уровень доступа для OAuth запроса \(под уровнем доступа понимается repo level, admin level…\)
5. Браузер отправляет информацию об аутентификации и подтверждает уровень доступа OAuth запроса.
6. **IDP** направляет браузер на **Redirect\_URI** вместе с **Code** и **State**.
7. Браузер переходит по редиректу на endpoint **RP** OAuth, направляет туда **Code** и **State**.
8. **RP** делает запрос на **IDP** пытаясь обменять **Code**, **Client\_Id**, **Redirect\_URI**, и **Client Secret** на **Access Token**.
   * Не путайте этот **Redirect\_URI** с тем, который был использован в шаге 2. Этот **Redirect\_URI**

      нельзя будет изменить, так как **RP** не отправляет этот запрос через браузер.
9. Если **Client Secret** и **Code** валидны для данного **Client\_Id**, то **IDP** вернет **Access Token** на **RP**.
10. Теперь **RP** хочет получить доступ к ресурсам пользователя. Можно просто сделать запрос на endpoint **IDP** с **Access Token в качестве параметра**. Чаще всего, это делается через обычный http заголовок.
11. Если **Access Token** валиден, **IDP** вернет ресурсы пользователя.

### Authorization Code with Proof Key for Code Exchange \(PKCE\)

![Picture from OAuth0.com](../../../../../.gitbook/assets/image%20%286%29.png)

{% hint style="info" %}
**App = RP  
Auth0 Tenant = IDP**
{% endhint %}

Из OAuth0.com:

1. Пользователь нажимает **Login** в приложении.
2. **RP** создает криптографически рандомный `code_verifier` и из него генерирует  `code_challenge`.
3. **RP** перенаправляет пользователя на **IDP** \(**/authorize** endpoint\) с `code_challenge`.
4. **IDP** перенаправляет пользователя на страницу входа и авторизации.
5. Пользователь аутентифицируется, используя одну из возможных опций логина и может увидеть страницу, на которой ему необходимо будет дать согласие на предоставление доступа приложению.
6. **IDP** сохраняет `code_challenge` и перенаправляет пользователя обратно в приложение с  authorization `code`.
7. **RP** направляет `code` и `code_verifier` \(созданный в шаге 2\) на **IDP** \(**/oauth/token** endpoint\).
8. **IDP** подтверждает `code_challenge` и `code_verifier`.
9. **IDP** отвечает, отдавая  ID Token and Access Token \(опционально, Refresh Token\).
10. **RP** может использовать Access Token для вызова API, чтобы получить доступ к информации о пользователе.
11. API отвечает, отдавая запрошенные данные.

[**Другие процессы**](https://auth0.com/docs/flows)\*\*\*\*

## Рекомендации

1. Используйте белые списки для url
2. Делайте временные объекты действительно временными
3. Обращайте внимание на конфигурацию \(белые списки, стандартные секреты\):
   1. Cookie flags - **secure**, **httponly**, **samesite**
   2. `Cache-Control: no-store` заголовки с каждым ответом, содержащим токены
4. Никогда не передавайте токены в заголовке `Referrer` 
5. Используйте лимиты для всех неустойчивых к перебору токенов

## Attacks & Testing

### Referer Header Leaks Code + State

Убедитесь, что после перенаправления с **IDP** на **RP**, Referer header не содержит URL параметров или удален, если возможно. Это предотвратит сценарий атаки, описанный ниже.

1. Если в любой точке после перенаправления на **RP** видно code и state в Referer header, то сайт уязвим.

### Insufficient URI Validation

1. Пройдите по процессу до шага 2, содержащего параметр`redirect_uri` 
2. Отредактируйте запрос согласно одному из следующих примеров: 
   1. aws.console.amazon.com/**myservice** → aws.console.amazon.com
   2. **aws**.console.amazon.com/myservice → console.amazon.com/myservice
   3. **aws.console.amazon.com**/myservice → evil.com/myservice
3. Если браузер перенаправился, тогда сайт уязвим к этой атаке.

{% hint style="info" %}
Не забудьте проверить, что сайт не отрезает Referer header или как-либо иначе обрезает URL параметры. Иначе Code / State будет сложно восстановить и это просто открытый редирект.
{% endhint %}

### Access Token Stored в Browser History / Cache

1. Откройте историю браузера и кэш и проверьте, не содержат ли Location entries приватной информации.

### State problems

Атакующий может организовать CSRF атаку через модифицированные Redirect URI и Code атакующего, чтобы аутентифицировать жертву используя вредоносный ресурс.

{% hint style="info" %}
Если жертва не подозревает, что код аутентификации был подменен, она может указать приватную информацию на подконтрольном атакующему ресурсу. Причина, по которой данная атака работает, заключается в том, что state параметр в шаге 2 уникален для сессии и если state не предоставлен в шаге 2 процесса OAuth, то не с чем сравнивать session token.
{% endhint %}

#### Lack of state

1. При первом обращении к IDP, убедитесь, что state передан через URL параметр.
2. Продолжайте проходить через процесс OAuth до тех пор, пока не получите Redirect URI.
3. Удостоверьтесь, что Redirect URI содержит state в URL параметре.
   * Проверьте, что сервис имеет множество OAuth Endpoint'ов или что он следует за Redirect URI и последний шаг действительно передает state на бэкенд RP.

#### Reused

1. При первом обращении к IDP, проверьте, что State передается в качестве URL параметра.
2. Продолжайте процесс, проверяя, что переменная State меняется в каждом запросе.

{% hint style="info" %}
Важно тестировать это в случае, когда процесс аутентификации через OAuth прошел успешно и в случае, когда он завершился неудачей по причине того, что пользователь отказал в доступе или потому, что Redirect URI не указывал на ожидаемый RP OAuth Endpoint.
{% endhint %}

#### Invalid validation

1. При первом запросе к IDP, модифицируйте параметр State, передаваемый как параметр URL, изменив его на некорректное значение.
2. Продолжайте процесс OAuth и проверяйте, что возвращенный code и некорректный state не приняты на RP.
3. Повторяйте шаги 1-3, не отправляя параметр state. Удостоверьтесь, что RP не принимает запросы от IDP.

#### Insecure

Переменная State должна быть обработана как CSRF токен. Если значение, хранящееся в переменной State предсказуемо или может быть перебрано с помощью brute force, то возможно, что атакующий сможет произвести множественную CSRF атаку в автоматизированном режиме и подобрать данные аутентификации пользователя. 

1. При первом запросе к IDP удостоверьтесь, что State передается в URL параметре.
2. Повторяйте этот процесс, проверяя, что у переменной State достаточно энтропии и она непредсказуема.

### Reusable authorization codes

Удостоверьтесь, позволит ли RP использовать один authorization code множество раз. Каждый код должен быть использован только для одной OAuth сессии,  повторное использование кода должно вызвать ошибку.

1. Полностью завершите процесс OAuth. Следите за authorization code, предоставленным IDP, сохраняйте эти значения.
2. Выберите этого же OAuth провайдера, начните перехватывать трафик, нажмите кнопку Connect.
3. Завершите процесс OAuth и проверьте, что возвращенный код отличается от кода в шаге 1.
4. Замените полученный код тем, что был сохранен в шаге 1.
5. Удостоверьтесь, что процесс OAuth выдает ошибку от RP или IDP.

## Ссылки

Много благодарностей:

* [Authorization code flow pentest guide](https://maxfieldchen.com/posts/2020-05-17-penetration-testers-guide-oauth-2.html)
* [RFC 6749](https://tools.ietf.org/html/rfc6749)
* [OAuth0](https://OAuth0.com)



